#!/bin/bash

set -o pipefail

# Dotfiles management command
# This script provides various commands to manage your dotfiles configuration

DOTFILES_DIR="$HOME/.cfg"
DOTFILES_STATE_DIR="$HOME/.local/state/dotfiles"
DOTFILES_ACTIVE_FILE="$DOTFILES_STATE_DIR/active"

# Colors for output
RED='\e[31m'
GREEN='\e[32m'
YELLOW='\e[33m'
CYAN='\e[36m'
RESET='\e[0m'

# Function to save active configuration
save_active_config() {
    local config="$1"
    mkdir -p "$DOTFILES_STATE_DIR"
    echo "$config" > "$DOTFILES_ACTIVE_FILE"
}

# Function to get active configuration
get_active_config() {
    if [ -f "$DOTFILES_ACTIVE_FILE" ]; then
        cat "$DOTFILES_ACTIVE_FILE"
    else
        echo ""
    fi
}

# Function to extract config from .bashrc
extract_config_from_bashrc() {
    if [ ! -f ~/.bashrc ]; then
        return 1
    fi

    # Search for source ~/.cfg/<config>/default/bash/rc pattern
    local config=$(grep -oP "source ~/.cfg/\K[^/]+" ~/.bashrc | head -n 1)
    if [ -n "$config" ]; then
        echo "$config"
        return 0
    fi
    return 1
}

# Function to display help
show_help() {
    cat << EOF
Usage: dotfiles <command> [options]

Dotfiles management tool for configuration installation and management.

Commands:
    install     Install a dotfiles configuration
    list        List available configurations
    current     Show the currently active configuration
    update      Update dotfiles repository from git
    help        Show this help message

Examples:
    dotfiles install          # Interactive installation of a config
    dotfiles list             # Show all available configurations
    dotfiles current          # Show the currently active configuration
    dotfiles update           # Pull latest changes from git repository
    dotfiles help             # Display this help message

EOF
}

# Function to list available configurations
list_configs() {
    if [ ! -d "$DOTFILES_DIR" ]; then
        echo -e "${RED}Error: Dotfiles directory not found at $DOTFILES_DIR${RESET}"
        exit 1
    fi

    echo -e "${GREEN}Available Configurations:${RESET}"
    mapfile -t CONFIGS < <(find "$DOTFILES_DIR" -mindepth 1 -maxdepth 1 -type d -not -name ".*" -not -name "shared" -exec basename {} \;)

    if [ ${#CONFIGS[@]} -eq 0 ]; then
        echo -e "${YELLOW}No configurations found.${RESET}"
        exit 0
    fi

    for CONFIG in "${CONFIGS[@]}"; do
        echo -e "  ${CYAN}•${RESET} $CONFIG"
    done
}

# Function to show the current active configuration
show_current() {
    local active_config=$(get_active_config)
    if [ -n "$active_config" ]; then
        echo -e "${GREEN}Current active configuration: ${CYAN}$active_config${RESET}"
    else
        echo -e "${YELLOW}No active configuration set.${RESET}"
    fi
}

# Function to install a configuration
install_config() {
    if [ ! -d "$DOTFILES_DIR" ]; then
        echo -e "${RED}Error: Dotfiles directory not found at $DOTFILES_DIR${RESET}"
        exit 1
    fi

    # Get list of available configs
    mapfile -t CONFIGS < <(find "$DOTFILES_DIR" -mindepth 1 -maxdepth 1 -type d -not -name ".*" -not -name "shared" -exec basename {} \;)

    if [ ${#CONFIGS[@]} -eq 0 ]; then
        echo -e "${RED}Error: No configurations found.${RESET}"
        exit 1
    fi

    # If a specific config is provided as argument, install it directly
    if [ -n "$1" ]; then
        CONFIG="$1"
        if [ ! -d "$DOTFILES_DIR/$CONFIG" ]; then
            echo -e "${RED}Error: Configuration '$CONFIG' not found.${RESET}"
            exit 1
        fi
    else
        # Interactive selection
        echo -e "${GREEN}Available Configurations:${RESET}"
        PS3=$'\e[36mSelect a configuration to install (enter number): \e[0m'
        select CONFIG in "${CONFIGS[@]}"; do
            if [ -n "$CONFIG" ]; then
                break
            else
                echo -e "${YELLOW}Invalid selection. Please try again.${RESET}"
            fi
        done
    fi

    if [ -n "$CONFIG" ]; then
        echo -e "${GREEN}\nInstalling $CONFIG...${RESET}"

        # Save the active configuration
        save_active_config "$CONFIG"

        # Check if dotfiles are already sourced in .bashrc
        if grep -q "source ~/.cfg/" ~/.bashrc 2>/dev/null; then
            echo -e "${YELLOW}Dotfiles already present in .bashrc, skipping shell and config setup.${RESET}"
        else
            # Add source command to .bashrc
            if [ -f ~/.bashrc ]; then
                echo "source ~/.cfg/$CONFIG/default/bash/rc" >> ~/.bashrc
                if [ -d "$DOTFILES_DIR/$CONFIG/bin" ]; then
                    echo "export PATH=\"\$HOME/.cfg/$CONFIG/bin:\$PATH\"" >> ~/.bashrc
                fi
            fi

            # Copy shared config if present
            if [ -d "$DOTFILES_DIR/shared/config" ]; then
                mkdir -p ~/.config/
                cp -r "$DOTFILES_DIR/shared/config/." ~/.config/
            fi

            # Copy config-specific files if present
            if [ -d "$DOTFILES_DIR/$CONFIG/config" ]; then
                mkdir -p ~/.config/
                cp -r "$DOTFILES_DIR/$CONFIG/config/." ~/.config/
            fi
        fi

        # Run install.sh only if present
        if [ -f "$DOTFILES_DIR/$CONFIG/install.sh" ]; then
            if ! source "$DOTFILES_DIR/$CONFIG/install.sh"; then
                echo -e "${RED}✗ Failed to install $CONFIG${RESET}"
                exit 1
            fi
        fi

        echo -e "${GREEN}✓ $CONFIG installed successfully!${RESET}"
    else
        echo -e "${RED}\nNo valid configuration selected. Aborting installation.${RESET}"
        exit 1
    fi
}

# Function to update dotfiles repository
update_dotfiles() {
    if [ ! -d "$DOTFILES_DIR" ]; then
        echo -e "${RED}Error: Dotfiles directory not found at $DOTFILES_DIR${RESET}"
        exit 1
    fi

    if [ ! -d "$DOTFILES_DIR/.git" ]; then
        echo -e "${RED}Error: $DOTFILES_DIR is not a git repository${RESET}"
        exit 1
    fi

    echo -e "${CYAN}Updating dotfiles from git repository...${RESET}"

    cd "$DOTFILES_DIR" || exit 1

    # Check if there are uncommitted changes
    if ! git diff-index --quiet HEAD -- 2>/dev/null; then
        echo -e "${YELLOW}Warning: You have uncommitted changes in the dotfiles directory.${RESET}"
        read -p $'\e[36mDo you want to stash them and continue? (y/N): \e[0m' choice < /dev/tty
        choice=${choice:-N}
        case "$choice" in
            y|Y )
                echo -e "${CYAN}Stashing local changes...${RESET}"
                git stash push -m "Auto-stash before dotfiles update at $(date)"
                STASHED=true
                ;;
            * )
                echo -e "${YELLOW}Update cancelled.${RESET}"
                exit 0
                ;;
        esac
    fi

    # Pull latest changes
    if git pull --rebase; then
        # If we stashed changes, ask to restore them
        if [ "${STASHED:-false}" = true ]; then
            echo -e "${CYAN}\nYour local changes were stashed.${RESET}"
            read -p $'\e[36mDo you want to restore them now? (y/N): \e[0m' restore_choice < /dev/tty
            restore_choice=${restore_choice:-N}
            case "$restore_choice" in
                y|Y )
                    if git stash pop; then
                        echo -e "${GREEN}✓ Local changes restored successfully!${RESET}"
                    else
                        echo -e "${YELLOW}Warning: Could not restore local changes automatically.${RESET}"
                        echo -e "${CYAN}Run 'git stash pop' manually in $DOTFILES_DIR to restore them.${RESET}"
                    fi
                    ;;
                * )
                    echo -e "${CYAN}Local changes remain stashed.${RESET}"
                    echo -e "${CYAN}Run 'git stash pop' in $DOTFILES_DIR to restore them later.${RESET}"
                    ;;
            esac
        fi
    else
        echo -e "${RED}✗ Failed to update dotfiles repository.${RESET}"
        echo -e "${CYAN}Please check your git configuration and try again.${RESET}"
        exit 1
    fi

    # Check and migrate active config if needed
    local active_config=$(get_active_config)
    if [ -z "$active_config" ]; then
        echo -e "${YELLOW}Active configuration not found. Attempting to recover from .bashrc...${RESET}"
        active_config=$(extract_config_from_bashrc)
        if [ -n "$active_config" ]; then
            echo -e "${GREEN}✓ Found configuration: $active_config${RESET}"
            save_active_config "$active_config"

            # Update .bashrc to use the standard pattern
            if [ -f ~/.bashrc ]; then
                echo -e "${CYAN}Updating .bashrc for alignment...${RESET}"
                # Remove old source lines
                sed -i "\|source ~/.cfg/$active_config/default/bash/rc|d" ~/.bashrc
                sed -i "\|export PATH=\"\$HOME/.cfg/$active_config/bin:\$PATH\"|d" ~/.bashrc

                # Add new source line
                echo "source ~/.cfg/$active_config/default/bash/rc" >> ~/.bashrc
                if [ -d "$DOTFILES_DIR/$active_config/bin" ]; then
                    echo "export PATH=\"\$HOME/.cfg/$active_config/bin:\$PATH\"" >> ~/.bashrc
                fi
                echo -e "${GREEN}✓ .bashrc updated${RESET}"
            fi
        else
            echo -e "${YELLOW}Could not determine active configuration. Skipping migration.${RESET}"
        fi
    fi
}

# Main command parser
case "${1:-}" in
    install)
        shift
        install_config "$@"
        ;;
    list)
        list_configs
        ;;
    current)
        show_current
        ;;
    update)
        update_dotfiles
        ;;
    help|--help|-h)
        show_help
        ;;
    "")
        show_help
        exit 1
        ;;
    *)
        echo -e "${RED}Unknown command: $1${RESET}\n"
        show_help
        exit 1
        ;;
esac
