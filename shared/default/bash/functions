# Generate a changelog between two git references (tags, commits, or current state)
create_gh_changelog() {
  local from=""
  local to=""
  local use_remote_head=true

  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case $1 in
      --from-tag)
        from="$2"
        shift 2
        ;;
      --from-commit)
        from="$2"
        shift 2
        ;;
      --to-tag)
        to="$2"
        use_remote_head=false
        shift 2
        ;;
      --to-commit)
        to="$2"
        use_remote_head=false
        shift 2
        ;;
      --to-now)
        use_remote_head=true
        shift
        ;;
      -h|--help)
        echo "Usage: create_gh_changelog [OPTIONS]"
        echo ""
        echo "Generate a changelog between two git references using GitHub API"
        echo ""
        echo "Options:"
        echo "  --from-tag TAG       Use a git tag as starting reference (required)"
        echo "  --from-commit SHA    Use a commit SHA as starting reference (required)"
        echo "  --to-tag TAG         Use a git tag as ending reference"
        echo "  --to-commit SHA      Use a commit SHA as ending reference"
        echo "  --to-now             Use latest commit on current branch in origin (default)"
        echo "  -h, --help           Show this help message"
        echo ""
        echo "Examples:"
        echo "  create_gh_changelog --from-tag v1.0.0 --to-tag v2.0.0"
        echo "  create_gh_changelog --from-commit abc123 --to-now"
        echo "  create_gh_changelog --from-tag v1.0.0"
        echo ""
        echo "Note: You must specify a 'from' reference. If 'to' is not specified,"
        echo "      it defaults to the current branch on origin remote"
        return 0
        ;;
      *)
        echo "Error: Unknown option '$1'"
        echo "Use -h or --help for usage information"
        return 1
        ;;
    esac
  done

  # Validate that from is specified
  if [ -z "$from" ]; then
    echo "Error: 'from' reference not specified"
    echo "Use --from-tag or --from-commit to specify the starting reference"
    return 1
  fi

  # Get current branch if needed
  if [ "$use_remote_head" = true ]; then
    local current_branch
    current_branch=$(git rev-parse --abbrev-ref HEAD)

    if [ "$current_branch" = "HEAD" ]; then
      echo "Error: Currently in detached HEAD state"
      return 1
    fi

    to="$current_branch"
  fi

  # Get origin remote URL and extract repo name
  local origin_url
  origin_url=$(git remote get-url origin)

  local repo
  # Extract owner/repo from various git URL formats and remove .git suffix
  if [[ "$origin_url" =~ github\.com[:/]([^/]+/[^/]+?)(\.git)?$ ]]; then
    repo="${BASH_REMATCH[1]}"
    # Remove .git suffix if present
    repo="${repo%.git}"
  else
    echo "Error: Could not parse GitHub repository from origin URL: $origin_url"
    return 1
  fi

  echo "Generating changelog from '$from' to '$to' for $repo..."
  echo ""

  gh api repos/$repo/compare/$from...$to \
    --jq '.commits[] |
      "* \(
          .commit.message
          | split("\n")[0]
          | sub("^(feat|fix|chore|refactor|test|docs|style|ci|build)(\\(.+\\))?:\\s*"; "")
        ) by @\(.author.login // "unknown")"'
}

# Create migration file
create_migration() {
  # Show usage if -h is passed
  if [[ "$1" == "-h" || "$1" == "--help" ]]; then
    echo "Usage: create_migration [optional:migrations_directory] [optional:migration_name]"
    echo "  migrations_directory: Directory to store migration files (default: current location)"
    echo "  migration_name: Name of the migration file (default: last git commit timestamp)"
    return 0
  fi

  local migrations_dir="${1:-.}"
  local migration_name="${2:-$(git log -1 --format=%cd --date=unix)}.sh"

  if [ ! -d "$migrations_dir" ]; then
    echo "Error: Migrations directory '$migrations_dir' does not exist"
    return 1
  fi

  local migration_file="$migrations_dir/$migration_name"
  touch $migration_file
  $EDITOR $migration_file
}

# SSH key management
ssh-key-put() {
  if [ "$#" -ne 1 ]; then
    echo "Usage: ssh-key-put <user@host> <optional:path_to_key (default: ~/.ssh/id_ed25519.pub)>"
    return 1
  fi

  if [ -n "$2" ]; then
    local SSH_KEY="$2"
  else
    local SSH_KEY="$HOME/.ssh/id_ed25519.pub"
  fi

  cat "$SSH_KEY" | ssh "$1" "mkdir -p ~/.ssh && chmod 700 ~/.ssh && cat >>  ~/.ssh/authorized_keys";
}

# Convert webm files generated by the Gnome screenshot video recorder to gifs
webm2gif() {
  input_file="$1"
  output_file="${input_file%.webm}.gif"
  ffmpeg -i "$input_file" -vf "fps=15,scale=500:-1:flags=lanczos,split[s0][s1];[s0]palettegen[p];[s1][p]paletteuse" "$output_file"
}

# Convert webm files generated by the Gnome screenshot video recorder to gifs (larger version)
webm2gif-large() {
  input_file="$1"
  output_file="${input_file%.webm}.gif"
  ffmpeg -i "$input_file" -vf "fps=15,scale=1000:-1:flags=lanczos,split[s0][s1];[s0]palettegen[p];[s1][p]paletteuse" "$output_file"
}

# Start a simple HTTP server
webserver() {
  # Show usage if -h is passed
  if [[ "$1" == "-h" || "$1" == "--help" ]]; then
    echo "Usage: webserver [-b] [port] [directory]"
    echo "  -b: Open default browser on <port>"
    echo "  port: Port number (default: 8000)"
    echo "  directory: Directory to serve (default: current directory)"
    return 0
  fi

  local open_browser=false
  if [[ "$1" == "-b" ]]; then
    open_browser=true
    shift
  fi

  local port=${1:-8000}
  local dir=${2:-.}

  if [ ! -d "$dir" ]; then
    echo "Error: Directory '$dir' does not exist"
    return 1
  fi

  # Check if port is already in use
  if lsof -i :$port >/dev/null 2>&1; then
    echo "Error: Port $port is already in use"
    return 1
  fi

  if [ "$open_browser" = true ]; then
    open "http://localhost:$port"
  fi

  python3 -m http.server $port --directory $dir
}